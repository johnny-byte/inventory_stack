
import json
import re
from typing import List
from pydantic import BaseModel, parse_file_as


class Record(BaseModel):
    id: int  # TODO make export Field alias
    internal_number: str
    reg_number: str
    name: str
    description: str
    serial_number: str
    date: str
    count: int
    price: str
    price__1: str


# type: regex patterns
types_regex = {
    "технология": r"Шуруповер|Углошлифовальная машина|клещи|Перфоратор|станок|Лобзик",
    "спортивный инвентарь/оборудование": r"\b(силовой тренажер|козел|конь|брусья|бревно)\b|Стойка для прыжков в высоту|Стойки волейбольные|Стрелковый тренажер|Комплект гимнастический|Щит фанерный тренировочный|Детский спорткомплекс|Пневматическая винтовка|бревн",
    "осциллограф": "осцилограф",
    "плита": "плита",
    "системный блок": "системный блок",
    "шторы": r"шторы|жалюзи",
    "мебель": r"Кухонный гарнитур|шкаф(?!\s*вытяжной)|стеллаж|Тумба|Тумбочка|\b(стол|столик|столовый)\b|Мягкий уголок|диван|Обеденная зона|Уголок отдыха|стул|мебели|Стенка|Полка",
    "холодильник": r"холодильник|Холодильная витрина|Машина холодильная",
    "вентиляционное оборудование": r"шкаф вытяжной|увлажнитель|Тепловентилятор|Облучатель|рециркулятор|Кондиционер",
    "телевизор": r"Плазма|Телевизор",
    "пк": r"(?<!Планшетный\s)\bКомпьютер\b|ПК|Системый блок",
    "проектор": "Проектор",
    "планшет": r"Планшетный компьютер|Планшет",
    "пианино": "Пианино",
    "палатка": "палатка",
    "ардуино": r"Образовательный набор|Лабораторный стенд \"ЛМ-АРЗ-1\" на базе платформы Ардуино",
    "ноутбук": "Ноутбук",
    "монитор": "Монитор",
    "микроскоп": "Микроскоп",
    "lego": r"LEGO|\bконструктор\b|NXT|Поле для соревнований",
    "картина": "картина",
    "доска": r"доска|Стойка для интерактивной доски SMAPT BOARD660/680",
    "книги": r"Книга|Учебн. пособие|литература|Учебники|учебник|Художественная лит-ра|Учебная литература|литература|В.Распутин|лит-ра|книги|Учебные пособи|Учебное пособие|Учебные издания|Прописи|Метод.пособие|Астафьев|Алгебра|Англо-русский",
    "сейф": "сейф",
    "радиосистема": "Радиосистема",
    "программа": "Программа",
    "мфу": r"МФУ|копир|Многофункциональное устройство|принтер сканер|XEROX",
    "принтер": r"(?<!МФУ)\w+Принтер(?!.*(МФУ|копир|сканер|многофункциональное устройство|Xerox))",
    "аудио / Видео":  r"\b(видеокамера|Аудио / Видео|проигр|радиосис|музык|вокал|Видео|Микрофон|Магнит|Усилитель|Микшер|Экволайзер|Звук|Электрогитара|Приставка|Колонки|Сабвуфер|камера)\b",
    "таблицы": "таблицы",
    "диспенсер": "Диспенсер",
    "dvd": r"(?<!Системный блок Celeron 430 \(1800 MHz\) 2Gb/160Gb/)DVD",
    "швейная машина": "Швейная машина",
    "факс": "Факс",
    "кухонное оборудование": r"Вытяжка|Протир-резательная машина|Ванна моечная|Машина посудомоечная напольная|Электросковорода|Тестомес|Сушилка для рук|Печь муфельная|Мясорубка",
    "оборудование для бассейна": r"Насос JP James|Сушуар|Оборудование для бассейна",
    "биология": r"скелет|Комплект фолии для кабинета биологии|Наглядное пособие электронное|Наборы моделей по биологии различные|Набор посуды и принадлежностей|Набор моделей|Влажные препараты",
    "квадрокоптер": "Квадрокоптер",
    "неизвестные науке создания": "Флипчарт на треноге",
    "экран для проектора": r"Экран для проектора|экран",
    "сетевое облорудование": r"Сетевой фильтр|Сетевой прибор|Сетевой|Сеть"
}


# var TypesInitData = []models.ItemType{
#   {Name: "Проектор", Icon: "0xf8d6|0x10f8d6", Keys: []string{"Проектор"}},
#   {Name: "Экран для проектора", Icon: "0xf685|0x10f685", Keys: []string{"Экран для проектора", "экран"}},
#   {Name: "Шторы", Icon: "0xf734|0x10f734", Keys: []string{"Шторы", "штор", "жалюзи"}},
#   {Name: "3D принтер", Icon: "0xf1b3|0x10f1b3", Keys: []string{"3D принтер", "3 D принтер", "3D-принтер", "3D-сканер"}},
#   {Name: "МФУ", Icon: "0xf68a|0x10f68a", Keys: []string{"МФУ", "копир", "Многофункциональное устройство", "принтер сканер", "XEROX"}},
#   {Name: "Принтер", Icon: "0xf02f|0x10f02f", Keys: []string{"Принтер"}},
#   {Name: "Сканер", Icon: "0xf8f3|0x10f8f3", Keys: []string{"Сканер"}},
#   {Name: "Набор для робототехники", Icon: "0xf2db|0x10f2db", Keys: []string{"Набор для робототехники", "Робот", "Ардуино", "Амперка", "Mindstorms", "WeDo", "Микрокомпьютер", "NXT", "TETRIX", "Lego"}},
#   {Name: "Аудио / Видео", Icon: "0xf87c|0x10f87c", Keys: []string{"Аудио / Видео", "проигр", "радиосис", "музык", "вокал", "Видео", "Микрофон", "Магнит", "Усилитель", "Микшер", "Экволайзер", "Звук", "Электрогитара", "Приставка", "Колонки", "Сабвуфер"}},
#   {Name: "Квадрокоптер", Icon: "0xf533|0x10f533", Keys: []string{"Квадрокопт"}},
#   {Name: "Мебель", Icon: "0xf4b8|0x10f4b8", Keys: []string{"Мебель", "Мебел", "диван", "отдыха", "Полка", "Стеллаж", "гарнитур", "Стол", "Стул", "Тумба", "Шкаф", "зона"}},
#   {Name: "Системный блок", Icon: "0xf37e|0x10f37e", Keys: []string{"Системный блок", "Server", "Систем", "Компьютер", "пк"}},
#   {Name: "Ноутбук", Icon: "0xf109|0x10f109", Keys: []string{"Ноутбук"}},
#   {Name: "Планшет", Icon: "0xf3fc|0x10f3fc", Keys: []string{"Планшет"}},
#   {Name: "Монитор", Icon: "0xf108|0x10f108", Keys: []string{"Монитор"}},
#   {Name: "Рециркулятор", Icon: "0xf8f4|0x10f8f4", Keys: []string{"Рециркулятор"}},
#   {Name: "Сейф", Icon: "0xf187|0x10f187", Keys: []string{"Сейф"}},
#   {Name: "Телевизор", Icon: "0xf26c|0x10f26c", Keys: []string{"Телевизор", "ТВ", "Плазма"}},
#   {Name: "Учебники", Icon: "0xf5db|0x10f5db", Keys: []string{"Учебники", "Книг", "Учебн", "Прописи", "Метод", "литерат", "Диск"}},
#   {Name: "Доска", Icon: "0xf51b|0x10f51b", Keys: []string{"Доска"}},
#   {Name: "Интерактивная доска", Icon: "0xf51c|0x10f51c", Keys: []string{"Интерактивная доска", "smart"}},
#   {Name: "Сетевое оборудование", Icon: "0xf6ff|0x10f6ff", Keys: []string{"Сетевое оборудование", "сетев", "cеть", "Точка", "роут"}},
#   {Name: "Мышь", Icon: "0xf8cc|0x10f8cc", Keys: []string{"Мышь"}},
#   {Name: "Клавиатура", Icon: "0xf11c|0x10f11c", Keys: []string{"Клавиатура"}},
#   {Name: "Веб-камера", Icon: "0xf832|0x10f832", Keys: []string{"Веб-камера"}},
#   {Name: "Документ-камера", Icon: "0xf81a|0x10f81a", Keys: []string{"Документ-камера"}},
#   {Name: "Колонтки", Icon: "0xf8e0|0x10f8e0", Keys: []string{"Колонтки"}},
#   {Name: "Наушники", Icon: "0xf590|0x10f590", Keys: []string{"Наушники"}},
#   {Name: "Сетевой фильтр", Icon: "0xf1e6|0x10f1e6", Keys: []string{"Сетевой фильтр"}},
# }

try:
    records = parse_file_as(List[Record], "data.json")

    used_record_ids = set()

    record_type = {}
    collected_errors = []
    unfiltered_records = []
    for record in records:
        for type, pattern in types_regex.items():
            match = re.search(pattern, record.name, re.IGNORECASE)
            if match:
                # самопроверка
                if record.id not in used_record_ids:
                    used_record_ids.add(record.id)
                else:
                    # collected_errors.append(f"add record with {record.name} in {type} already used in {record_type[record.id]}")
                    # если много ошибок раскомментировать сторку выше и закомментировать строку ниже тогда все ошибки выведутся сразу
                    raise RuntimeError(
                        f"add record with {record.id=} in {type} already used in {record_type[record.id]}")
                # сохраняем значение
                record_type[record.id] = type

        else:
            unfiltered_records.append(record)
    else:
        for record in unfiltered_records:
            record_type[record.id] = "другое"

        assert len(record_type.keys()) == len(records)

        # для отладки
        for i, e in enumerate(collected_errors):
            print(i, e)

        # with open("unfiltered.json", "wb") as file:
        #     for r in unfiltered_records:
        #         # print(r)
        #         file.write(f"{r.id} {r.name}\n".encode("utf-8"))
            # break
        # file.write(str(r))
        # file.write("["+",".join([str(r.dict()) for r in unfiltered_records])+"]")

    updated_records = []
    for record_id, type in record_type.items():
        record = next(filter(lambda r: r.id == record_id, records))
        dict_record = record.dict()
        dict_record["type"] = type
        updated_records.append(dict_record)

    # возвращает массив записей
    # FIXME: пишет строки как \uxxx не знаю как фиксить
    with open("data_with_types.json", "w") as file:
        json.dump(updated_records, file)

except Exception as e:
    print(e)
    raise e
